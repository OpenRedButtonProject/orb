#!/usr/bin/env python3
# Copyright 2024 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Generates VirtualKeyCodes.java from C++ source files.

This script parses virtual key code constants from the ORB library's C++ source
files (base_app.cpp and opapp.cpp) and generates a Java class with matching
constant definitions. This ensures the Java and C++ constants stay in sync.

Usage:
    generate_virtual_keycodes.py --output <output_java_file>
                                  --base-app-cpp <path_to_base_app.cpp>
                                  --opapp-cpp <path_to_opapp.cpp>
"""

import argparse
import os
import re
import sys


# Pattern to match C++ constant definitions like:
#   const uint16_t VK_RED = 403;
CONST_PATTERN = re.compile(
    r'const\s+uint16_t\s+(VK_\w+)\s*=\s*(\d+)\s*;'
)

# Pattern to match commented constant definitions like:
#   //             VK_GUIDE        = 458;
# These are documented in the spec but not defined as actual constants.
COMMENTED_CONST_PATTERN = re.compile(
    r'//\s*(VK_\w+)\s*=\s*(\d+)\s*;?'
)


def parse_cpp_constants(cpp_file_path):
    """Parse VK_* constants from a C++ source file.

    Parses both actual const definitions and commented definitions.
    Commented definitions are included because the ORB library documents
    the full range of spec-defined keys even when not all are used in code.

    Args:
        cpp_file_path: Path to the C++ source file.

    Returns:
        Dictionary mapping constant names to their integer values.
    """
    constants = {}
    try:
        with open(cpp_file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            # Parse actual const definitions
            for match in CONST_PATTERN.finditer(content):
                name = match.group(1)
                value = int(match.group(2))
                constants[name] = value
            # Parse commented definitions (documented in spec but not used in code)
            for match in COMMENTED_CONST_PATTERN.finditer(content):
                name = match.group(1)
                value = int(match.group(2))
                # Don't override actual definitions with commented ones
                if name not in constants:
                    constants[name] = value
    except IOError as e:
        print(f'Error reading {cpp_file_path}: {e}', file=sys.stderr)
        sys.exit(1)
    return constants


def generate_java(constants, output_path):
    """Generate the VirtualKeyCodes.java file.

    Args:
        constants: Dictionary mapping constant names to their integer values.
        output_path: Path to write the generated Java file.
    """
    # Ensure output directory exists
    output_dir = os.path.dirname(output_path)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Group constants by category for readability
    nav_keys = []
    color_keys = []
    numeric_keys = []
    vcr_keys = []
    opapp_keys = []
    other_keys = []

    for name, value in sorted(constants.items()):
        if name in ('VK_UP', 'VK_DOWN', 'VK_LEFT', 'VK_RIGHT', 'VK_ENTER', 'VK_BACK'):
            nav_keys.append((name, value))
        elif name in ('VK_RED', 'VK_GREEN', 'VK_YELLOW', 'VK_BLUE'):
            color_keys.append((name, value))
        elif name.startswith('VK_NUMERIC') or (len(name) == 4 and name[3].isdigit()):
            numeric_keys.append((name, value))
        elif name in ('VK_PLAY', 'VK_STOP', 'VK_PAUSE', 'VK_FAST_FWD', 'VK_REWIND',
                      'VK_NEXT', 'VK_PREV', 'VK_PLAY_PAUSE', 'VK_RECORD'):
            vcr_keys.append((name, value))
        elif name in ('VK_CHANNEL_UP', 'VK_CHANNEL_DOWN', 'VK_INFO', 'VK_GUIDE',
                      'VK_CHANNELS', 'VK_MENU', 'VK_VOLUME_UP', 'VK_VOLUME_DOWN',
                      'VK_MUTE', 'VK_SUBTITLE', 'VK_AUDIO_TRACK', 'VK_AUDIO_DESC',
                      'VK_EXIT'):
            opapp_keys.append((name, value))
        else:
            other_keys.append((name, value))

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write('''\
// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by third_party/orb/scripts/generate_virtual_keycodes.py
// Source files:
//   - third_party/orb/orblibrary/moderator/app_mgr/base_app.cpp
//   - third_party/orb/orblibrary/moderator/app_mgr/opapp.cpp

package org.chromium.content_shell;

/**
 * Virtual key codes for HbbTV and OpApp key handling.
 * These values match the DOM KeyboardEvent.keyCode values expected by
 * HbbTV/OpApp applications and must stay in sync with the C++ definitions
 * in the ORB library.
 *
 * @see <a href="https://www.etsi.org/deliver/etsi_ts/103600_103699/103606/">
 *      ETSI TS 103 606</a>
 */
public final class VirtualKeyCodes {

    // Prevent instantiation
    private VirtualKeyCodes() {}

    /** Invalid/unmapped key code. */
    public static final int VK_INVALID = 0;

''')

        def write_section(title, keys):
            if keys:
                f.write(f'    // {title}\n')
                for name, value in sorted(keys, key=lambda x: x[1]):
                    f.write(f'    public static final int {name} = {value};\n')
                f.write('\n')

        write_section('Navigation keys', nav_keys)
        write_section('Color keys (HbbTV)', color_keys)
        write_section('Numeric keys', numeric_keys)
        write_section('VCR/Media control keys', vcr_keys)
        write_section('Operator Application keys (TS 103 606 Table 17)', opapp_keys)
        write_section('Other keys', other_keys)

        f.write('}\n')


def main():
    parser = argparse.ArgumentParser(
        description='Generate VirtualKeyCodes.java from C++ source files.')
    parser.add_argument(
        '--output', required=True,
        help='Path to output Java file')
    parser.add_argument(
        '--base-app-cpp', required=True,
        help='Path to base_app.cpp')
    parser.add_argument(
        '--opapp-cpp', required=True,
        help='Path to opapp.cpp')

    args = parser.parse_args()

    # Parse constants from both C++ files
    constants = {}
    constants.update(parse_cpp_constants(args.base_app_cpp))
    constants.update(parse_cpp_constants(args.opapp_cpp))

    if not constants:
        print('Warning: No VK_* constants found in source files',
              file=sys.stderr)

    # Generate the Java file
    generate_java(constants, args.output)

    print(f'Generated {args.output} with {len(constants)} constants')
    return 0


if __name__ == '__main__':
    sys.exit(main())
